#!/usr/bin/env zsh
#
# Recursively get information about git workspaces (short-style)
# Uses findGitRepos to tell where to look
#

autoload colors && colors

repo=()
names=()
branches=()
files=()

count=0

longestrepo=0
longestname=0
longestbranch=0
longestfiles=0

strlen() {
  local ansistr="$(echo $* | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g")"

  echo -n ${#ansistr}
}

pad_to_longest() {
  local target=$1
  local str="$2"
  local len=$(strlen $str)
  local output="$str"
  local neg="${3:-}"

  if [ $len -lt $target ]; then
    local pad=0
    (( pad = $target - $len ))
    if [ "$neg" = "-" ]; then
      output="$(printf "%s%*s" "$str" $pad ' ')"
    else
      output="$(printf "%*s%s" $pad ' ' "$str")"
    fi
  fi

  echo -n "$output"
}

for i in `findGitRepos`; do
  cd $i

  lines=("${(@f)$(vcsstatus --output=statusline --color)}")

  p="$(echo $lines[1] | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g")"
  b="$lines[3]"
  f="$lines[4]"
  dir="$fg_bold[black]$(shortenpath "$lines[5]")$reset_color"
  n="${dir:h}/$fg_no_bold[cyan]$lines[2]$reset_color"

  repo+=("$p")
  names+=("$n")
  branches+=("$b")
  files+=("$f")

  len=$(strlen $p)
  [ $len -gt $longestrepo ] && longestrepo=$len

  len=$(strlen $n)
  [ $len -gt $longestname ] && longestname=$len

  len=$(strlen $b)
  [ $len -gt $longestbranch ] && longestbranch=$len

  len=$(strlen $f)
  [ $len -gt $longestfiles ] && longestfiles=$len

  (( count = count + 1 ))
done

for i in {1..$count}; do
  p="$(pad_to_longest $longestrepo "$repo[$i]")"
  n="$(pad_to_longest $longestname "$names[$i]")"
  b="$(pad_to_longest $longestbranch "$branches[$i]" '-')"
  f="$(pad_to_longest $longestfiles "$files[$i]" '-')"

  printf "  %s $fg[blue](%s)$reset_color | %s | %s\n" "$n" "$p" "$b" "$f"
done

